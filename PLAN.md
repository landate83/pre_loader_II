# План реализации проекта Point Cloud to GLB Converter

## Обзор проекта

CLI-утилита для конвертации облаков точек (.ply/.sog) в формат GLB с Draco-компрессией + веб-просмотрщик с шейдерными анимациями.

---

## Этап 1: Настройка проекта и структуры

### 1.1 Создание структуры директорий
- [ ] Создать директорию `converter/` с `__init__.py`
- [ ] Создать директорию `viewer/js/`
- [ ] Создать директорию `tests/`
- [ ] Создать `requirements.txt` с зависимостями

### 1.2 Инициализация Python пакета
- [ ] Создать `converter/__init__.py` (может быть пустым)
- [ ] Настроить структуру для импорта модулей

---

## Этап 2: Реализация модуля чтения (reader.py)

### 2.1 Базовые функции чтения
- [ ] Реализовать `read_ply()`:
  - Чтение координат (x, y, z)
  - Извлечение цветов RGB (если есть)
  - Обработка отсутствия цветов (белый по умолчанию)
- [ ] Реализовать `read_sog()`:
  - Чтение координат
  - Конвертация Spherical Harmonics (f_dc_0, f_dc_1, f_dc_2) в RGB
  - Формула: `(0.5 + SH_C0 * f_dc_i) * 255`
- [ ] Реализовать `read_point_cloud()`:
  - Определение формата по расширению
  - Маршрутизация к соответствующей функции
  - Обработка ошибок неподдерживаемых форматов

### 2.2 Тестирование reader.py
- [ ] Тест чтения .ply с цветами
- [ ] Тест чтения .ply без цветов
- [ ] Тест чтения .sog с SH
- [ ] Тест обработки неподдерживаемых форматов

---

## Этап 3: Реализация модуля прореживания (downsampler.py)

### 3.1 Алгоритм Voxel Grid Nearest
- [ ] Реализовать `downsample_voxel_grid_nearest()`:
  - Вычисление индексов вокселей
  - Нормализация индексов (offset)
  - Генерация уникальных ключей вокселей
  - Группировка точек по вокселям
  - Выбор ближайшей к центроиду точки в каждом вокселе
  - **Критично**: сохранение оригинальных координат (не усреднение!)

### 3.2 Бинарный поиск размера вокселя
- [ ] Реализовать `find_voxel_size_for_target()`:
  - Вычисление диагонали bounding box
  - Бинарный поиск размера вокселя
  - Проверка достижения целевого количества точек
  - Допустимая погрешность 5%

### 3.3 Функция прореживания до цели
- [ ] Реализовать `downsample_to_target()`:
  - Поддержка `target_count` (количество точек)
  - Поддержка `target_size_bytes` (размер в байтах)
  - Конвертация размера в количество (~14 байт/точка после Draco)
  - Обработка случая, когда целевое количество >= исходного

### 3.4 Тестирование downsampler.py
- [ ] Тест прореживания с target_count
- [ ] Тест прореживания с target_size_bytes
- [ ] Тест сохранения оригинальных координат
- [ ] Тест точности достижения целевого количества
- [ ] Тест обработки случая без прореживания

---

## Этап 4: Реализация модуля экспорта (exporter.py)

### 4.1 Создание GLB структуры
- [ ] Реализовать `_create_glb()`:
  - Конвертация цветов в float32 [0, 1]
  - Создание бинарных буферов для позиций и цветов
  - Настройка GLTF2 структуры:
    - Scene, Node, Mesh
    - Primitive с атрибутами POSITION и COLOR_0
    - Accessors с правильными типами и границами
    - BufferViews с правильными offset и length
    - Buffer с объединёнными данными
  - Сохранение GLB файла

### 4.2 Интеграция Draco-компрессии
- [ ] Реализовать `export_glb_with_draco()`:
  - Создание временного GLB файла
  - Вызов `draco_transcoder` через subprocess:
    - Параметры: `-cl 7`, `-qp 14`, `-qc 10`
  - Удаление временного файла
  - Возврат размера итогового файла
  - Обработка ошибок subprocess

### 4.3 Тестирование exporter.py
- [ ] Тест создания GLB без Draco
- [ ] Тест экспорта с Draco (если установлен draco_transcoder)
- [ ] Тест корректности структуры GLB
- [ ] Тест обработки ошибок

---

## Этап 5: Реализация CLI (cli.py)

### 5.1 Парсинг аргументов
- [ ] Реализовать `parse_size()`:
  - Поддержка суффиксов: b, kb, mb, gb
  - Конвертация в байты
  - Обработка регистра (lowercase)

### 5.2 CLI команда
- [ ] Настроить Click команду:
  - Аргумент: `input_file` (обязательный, существующий файл)
  - Опция: `-o, --output` (обязательная)
  - Опция: `--points` (целое число)
  - Опция: `--size` (строка с суффиксом)
  - Опция: `-v, --verbose` (флаг)
- [ ] Реализовать `main()`:
  - Валидация: хотя бы один из `--points` или `--size`
  - Чтение облака точек
  - Вывод информации в verbose режиме
  - Прореживание
  - Экспорт в GLB
  - Вывод результата

### 5.3 Тестирование CLI
- [ ] Тест с `--points`
- [ ] Тест с `--size`
- [ ] Тест валидации аргументов
- [ ] Тест verbose режима

---

## Этап 6: Реализация веб-просмотрщика (viewer/)

### 6.1 HTML структура (index.html)
- [ ] Создать базовую HTML структуру
- [ ] Добавить canvas элемент
- [ ] Реализовать dropzone:
  - Drag & drop область
  - Кнопка "Открыть файл"
  - Скрытый file input
  - Стилизация (тёмная тема, dashed border)
- [ ] Реализовать панель управления:
  - Секция "Информация" (точки, размер)
  - Секция "Отображение" (размер точек, прозрачность, цвет)
  - Секция "Анимации" (кнопки выбора, скорость, амплитуда, кнопка воспроизведения)
- [ ] Встроить стили (CSS в `<style>`)
- [ ] Настроить importmap для Three.js
- [ ] Подключить main.js как модуль

### 6.2 JavaScript логика (js/main.js)

#### 6.2.1 Инициализация Three.js
- [ ] Создать сцену, камеру, рендерер
- [ ] Настроить камеру (PerspectiveCamera)
- [ ] Настроить рендерер (WebGLRenderer, размер canvas)
- [ ] Добавить обработку изменения размера окна
- [ ] Настроить OrbitControls для навигации

#### 6.2.2 Загрузка файлов
- [ ] Реализовать drag & drop:
  - Обработка dragover, drop событий
  - Предотвращение стандартного поведения
  - Извлечение файла из события
- [ ] Реализовать file input:
  - Обработка change события
  - Получение выбранного файла
- [ ] Реализовать загрузку GLB:
  - Использование GLTFLoader и DRACOLoader
  - Настройка DRACOLoader decoder path
  - Извлечение геометрии и атрибутов
  - Создание Points материала и объекта
  - Добавление в сцену
  - Скрытие dropzone, показ панели
- [ ] Реализовать загрузку .ply/.sog:
  - Парсинг PLY файла (или использование библиотеки)
  - Создание BufferGeometry
  - Создание Points объекта

#### 6.2.3 Управление отображением
- [ ] Реализовать изменение размера точек:
  - Слушатель input события для `#point-size`
  - Обновление `size` в материале
  - Обновление отображаемого значения
- [ ] Реализовать изменение прозрачности:
  - Слушатель для `#opacity`
  - Обновление `opacity` и `transparent` в материале
  - Обновление отображаемого значения
- [ ] Реализовать переключение цветов:
  - Слушатель для radio buttons `name="cm"`
  - Режим "file": использование цветов из файла
  - Режим "custom": использование выбранного цвета
  - Обновление материала

#### 6.2.4 Система анимаций
- [ ] Реализовать базовую структуру анимаций:
  - Объект для хранения текущей анимации
  - Функция переключения анимации
  - Обработка кнопок выбора анимации
- [ ] Реализовать шейдерные материалы для каждой анимации:
  - Базовый vertex shader с uniform переменными
  - Fragment shader для точек
  - Функции easing (easeOutBounce, easeOutExpo)
  - Функция hash для псевдослучайных значений
  - Функция snoise для шума (для morph)

#### 6.2.5 Реализация конкретных анимаций
- [ ] **Rain (Дождь)**:
  - Задержка на основе gl_VertexID
  - Стартовая позиция выше финальной
  - Анимация падения с easeOutBounce
- [ ] **Wave (Волна)**:
  - Расстояние от центра на плоскости XZ
  - Волновая функция с задержкой по расстоянию
  - Вертикальное смещение
- [ ] **Tornado (Смерч)**:
  - Спиральное движение к центру
  - Радиус воронки уменьшается
  - Угол вращения на основе времени и ID
- [ ] **Explosion (Взрыв)**:
  - Направление от центра
  - Радиус взрыва с вариацией
  - Анимация возврата с easeOutExpo
- [ ] **Morph (Морфинг)**:
  - Шумовая функция на основе позиции и времени
  - Смещение точек
  - Плавный переход

#### 6.2.6 Управление анимациями
- [ ] Реализовать слайдер скорости:
  - Слушатель для `#anim-speed`
  - Масштабирование времени в шейдерах
  - Обновление отображаемого значения
- [ ] Реализовать слайдер амплитуды:
  - Слушатель для `#anim-amp`
  - Передача в шейдеры как uniform
  - Обновление отображаемого значения
- [ ] Реализовать кнопку воспроизведения:
  - Сброс времени анимации
  - Перезапуск анимации
- [ ] Реализовать анимационный цикл:
  - requestAnimationFrame
  - Обновление времени
  - Обновление uniform переменных
  - Рендеринг сцены

#### 6.2.7 Информационная панель
- [ ] Обновление количества точек:
  - Извлечение из загруженной геометрии
  - Форматирование с разделителями тысяч
- [ ] Обновление размера файла:
  - Получение размера загруженного файла
  - Форматирование (байты, KB, MB)

---

## Этап 7: Тестирование

### 7.1 Unit тесты
- [ ] Тесты для reader.py (≥80% покрытие)
- [ ] Тесты для downsampler.py (≥80% покрытие)
- [ ] Тесты для exporter.py (≥80% покрытие)
- [ ] Тесты для cli.py (≥80% покрытие)

### 7.2 Интеграционные тесты
- [ ] Тест полного pipeline: .ply → прореживание → GLB
- [ ] Тест полного pipeline: .sog → прореживание → GLB
- [ ] Тест CLI с различными параметрами

### 7.3 Тестирование веб-просмотрщика
- [ ] Тест загрузки GLB файла
- [ ] Тест drag & drop
- [ ] Тест всех анимаций
- [ ] Тест управления отображением
- [ ] Тест на различных браузерах

---

## Этап 8: Документация и финализация

### 8.1 Документация
- [ ] README.md с описанием проекта
- [ ] Инструкции по установке
- [ ] Примеры использования CLI
- [ ] Описание веб-просмотрщика

### 8.2 Проверка критериев готовности
- [ ] CLI: .ply и .sog → .glb ✓
- [ ] CLI: --points и --size ✓
- [ ] GLB читается Three.js + DRACOLoader ✓
- [ ] Координаты = оригинальные (не усреднённые) ✓
- [ ] Viewer: drag&drop ✓
- [ ] Viewer: инфо-панель (точки, размер) ✓
- [ ] Viewer: размер/цвет/прозрачность точек ✓
- [ ] Viewer: 5 анимаций (rain, wave, tornado, explosion, morph) ✓
- [ ] Тесты ≥80% ✓

---

## Порядок реализации (рекомендуемый)

1. **Этап 1** - Настройка проекта
2. **Этап 2** - reader.py (базовая функциональность)
3. **Этап 3** - downsampler.py (критично для качества)
4. **Этап 4** - exporter.py (зависит от reader и downsampler)
5. **Этап 5** - cli.py (объединяет всё)
6. **Этап 6** - viewer/ (независимый компонент)
7. **Этап 7** - Тестирование
8. **Этап 8** - Документация

---

## Зависимости и требования

### Python зависимости
- numpy >= 1.24.0
- open3d >= 0.17.0 (может не использоваться напрямую, но указан в requirements)
- plyfile >= 1.0.0
- pygltflib >= 1.16.0
- click >= 8.0.0

### Системные зависимости
- draco-tools (для draco_transcoder)
  - Установка: `sudo apt install draco-tools` (Linux)
  - Или через другие пакетные менеджеры

### Веб зависимости
- Three.js r160+ (через CDN)
- DRACOLoader (встроен в Three.js examples)

---

## Потенциальные проблемы и решения

1. **Draco transcoder не найден**
   - Решение: Проверка наличия в системе, инструкции по установке

2. **Большие файлы .ply/.sog**
   - Решение: Прореживание перед обработкой, потоковая обработка

3. **Производительность шейдеров**
   - Решение: Оптимизация шейдерного кода, LOD для больших облаков

4. **Совместимость браузеров**
   - Решение: Проверка WebGL 2.0, fallback на WebGL 1.0 если нужно

---

## Метрики успеха

- ✅ Все критерии готовности выполнены
- ✅ Покрытие тестами ≥80%
- ✅ CLI работает с .ply и .sog
- ✅ GLB файлы открываются в стандартных просмотрщиках
- ✅ Веб-просмотрщик работает в современных браузерах
- ✅ Все 5 анимаций работают корректно


